<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;  /* –±—ã–ª–æ: height: 100vh */
            overflow-y: auto;   /* –±—ã–ª–æ: overflow: hidden */
        }
        
        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;  /* –±—ã–ª–æ: height: 100vh */
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }
        
        .videos {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            flex: 1;
            margin-bottom: 20px;
        }
        
        .video-container {
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-warning {
            background: #ed8936;
            color: white;
        }
        
        .status {
            background: white;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .status.connected {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .status.disconnected {
            background: #fed7d7;
            color: #742a2a;
        }
        
        @media (max-width: 768px) {
            .videos {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìπ WebRTC Video Chat</h1>
            <p>Peer-to-peer video calling with TURN server</p>
        </div>
        
        <div id="status" class="status disconnected">
            üî¥ Disconnected
        </div>
        
        <div class="videos">
            <div class="video-container">
                <div class="video-label">üì∑ Your Video</div>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div class="video-container">
                <div class="video-label">üë§ Remote Video</div>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <input type="text" id="roomId" placeholder="Enter Room ID" value="room123">
                <button class="btn-primary" onclick="joinRoom()">üö™ Join Room</button>
            </div>
            
            <div class="control-group">
                <button class="btn-success" onclick="startCall()">üìû Call</button>
                <button class="btn-danger" onclick="hangUp()">üìµ Hang Up</button>
            </div>
            
            <div class="control-group">
                <button class="btn-warning" onclick="toggleAudio()">üé§ Mute/Unmute</button>
                <button class="btn-warning" onclick="toggleVideo()">üìπ Video On/Off</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    
    <script>
        const serverIP = window.location.hostname;
        let localStream;
        let remoteStream;
        let peerConnection;
        let stompClient;
        let currentRoom;
        
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        
        // WebRTC Configuration —Å –≤–∞—à–∏–º TURN —Å–µ—Ä–≤–µ—Ä–æ–º
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                {
                    urls: `turn:${serverIP}:3478`,
                    username: 'videochat',
                    credential: 'secretpass123'
                }
            ]
        };
        
        // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket
        function connectWebSocket() {
            const socket = new SockJS('/ws');
            stompClient = Stomp.over(socket);
            
            stompClient.connect({}, function(frame) {
                updateStatus('connected', 'üü¢ Connected to server');
                console.log('Connected: ' + frame);
            }, function(error) {
                updateStatus('disconnected', 'üî¥ Connection failed');
                console.error('Connection error:', error);
            });
        }
        
        // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ
        function joinRoom() {
            currentRoom = document.getElementById('roomId').value;
            if (!currentRoom) {
                alert('Please enter a room ID!');
                return;
            }
            
            // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã
            stompClient.subscribe('/topic/webrtc/' + currentRoom, function(message) {
                const data = JSON.parse(message.body);
                handleSignalingData(data);
            });
            
            updateStatus('connected', `üü¢ Joined room: ${currentRoom}`);
        }
        
        // –ü–æ–ª—É—á–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤–∏–¥–µ–æ
        async function getLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                return true;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Cannot access camera/microphone!');
                return false;
            }
        }
        
        // –ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫
        async function startCall() {
            if (!currentRoom) {
                alert('Please join a room first!');
                return;
            }
            
            if (!localStream) {
                const success = await getLocalStream();
                if (!success) return;
            }
            
            // –°–æ–∑–¥–∞—Ç—å peer connection
            peerConnection = new RTCPeerConnection(configuration);
            
            // –î–æ–±–∞–≤–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–∫–∏
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Ç—Ä–µ–∫–æ–≤
            peerConnection.ontrack = (event) => {
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                    remoteVideo.srcObject = remoteStream;
                }
                remoteStream.addTrack(event.track);
            };
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignalingData({
                        type: 'ice-candidate',
                        data: event.candidate
                    });
                }
            };
            
            // –°–æ–∑–¥–∞—Ç—å offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            sendSignalingData({
                type: 'offer',
                data: offer
            });
            
            updateStatus('connected', 'üü¢ Calling...');
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        async function handleSignalingData(message) {
            const { type, data } = message;
            
            if (type === 'offer') {
                if (!localStream) {
                    await getLocalStream();
                }
                
                peerConnection = new RTCPeerConnection(configuration);
                
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                peerConnection.ontrack = (event) => {
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        remoteVideo.srcObject = remoteStream;
                    }
                    remoteStream.addTrack(event.track);
                };
                
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignalingData({
                            type: 'ice-candidate',
                            data: event.candidate
                        });
                    }
                };
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                sendSignalingData({
                    type: 'answer',
                    data: answer
                });
                
                updateStatus('connected', 'ÔøΩÔøΩ In call');
            }
            else if (type === 'answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                updateStatus('connected', 'üü¢ Connected!');
            }
            else if (type === 'ice-candidate') {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data));
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
        }
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        function sendSignalingData(message) {
            stompClient.send('/app/webrtc/' + message.type, {}, JSON.stringify({
                type: message.type,
                from: currentRoom,
                to: currentRoom,
                data: message.data
            }));
        }
        
        // –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫
        function hangUp() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }
            
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            
            updateStatus('connected', 'üü¢ Call ended');
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∞—É–¥–∏–æ
        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                }
            }
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –≤–∏–¥–µ–æ
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                }
            }
        }
        
        // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
        function updateStatus(status, message) {
            statusDiv.className = 'status ' + status;
            statusDiv.textContent = message;
        }
        
        // –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.onload = function() {
            connectWebSocket();
        };
        
        // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.onbeforeunload = function() {
            hangUp();
        };
    </script>
</body>
</html>
